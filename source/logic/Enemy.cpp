////////////////////////////////////////////////////////////
//
// Acodemia Copyright (C) Jacek Kwiatek 2022
// e-mail: jackflower (at) poczta.onet.pl
// acodemia.pl
//
// To oprogramowanie dostarczane jest w postaci takiej,
// w jakiej jest, bez wyraźnych ani domniemanych gwarancji.
//
// W żadnym wypadku Autor nie ponosi odpowiedzialności
// za jakiekolwiek szkody powstałe w wyniku korzystania
// z tego oprogramowania.
//
// Zezwala się na korzystanie z tego oprogramowania
// w dowolnym celu, także komercyjnym. Można je zmienić
// i swobodnie rozpowszechniać.
//
// Zastrzega się następujące ograniczenia:
//
// 1. Jeśli używasz tego oprogramowania w swoich
//    produktach, potwierdzenie pochodzenia tego
//    oprogramowania w dokumentacji produktu,
//    byłoby docenione, ale nie jest wymagane.
//
////////////////////////////////////////////////////////////

#include "Enemy.hpp"
#include "../logic/Bullet.hpp"
#include "../entityengine/Game.hpp"

namespace logic
{

	// Default constructor 
	Enemy::Enemy() :
		Actor{}, // base class constructor
		m_selfdestruction_token{ false },
		m_trigger{}
	{
	}

	// Copy constructor
	Enemy::Enemy(const Enemy& copy) :
		Actor{ copy }, // base class copy constructor
		m_selfdestruction_token{ copy.m_selfdestruction_token },
		m_trigger{ copy.m_trigger }
	{
	}

	// Move constructor
	Enemy::Enemy(Enemy&& other) :
		Actor{ other }, // base class move constructor
		m_selfdestruction_token{ other.m_selfdestruction_token },
		m_trigger{ other.m_trigger }
	{
	}

	// Virtual destructor
	Enemy::~Enemy()
	{
		m_selfdestruction_token = false;
	}

	// Overloaded copy assignment operator
	Enemy& Enemy::operator=(const Enemy& copy)
	{
		if (this != &copy)
		{
			Actor::operator=(copy);
			m_selfdestruction_token = copy.m_selfdestruction_token;
			m_trigger = copy.m_trigger;
		}
		return *this;
	}

	// Overloaded move assignment operator
	Enemy& Enemy::operator=(Enemy&& other)
	{
		if (this != &other)
		{
			Actor::operator=(other);
			m_selfdestruction_token = other.m_selfdestruction_token;
			m_trigger = other.m_trigger;
		}
		return *this;
	}

	// Method returns the rate of fire
	const float Enemy::getRateFire() const
	{
		return m_trigger.getFrequency();
	}

	// Method sets the rate of fire
	void Enemy::setRateFire(float rate_fire)
	{
		m_trigger.setFrequency(rate_fire);
	}

	// Virtual method updates the object 
	void Enemy::update(float dt)
	{
		move(m_movement * m_velocity * dt); // enemy position update

		// activation of self-destruct when an object enters the camera area
		if (!m_selfdestruction_token and inCamera())
			m_selfdestruction_token = true;

		// m_selfdestruction_token is active and the object leaves the camera area - it dies 
		if (m_selfdestruction_token and not inCamera())
			setDestruction(true);
			
		m_trigger.update(dt);

		if (m_trigger.getEnabled() and inCamera())
		{
			m_signal_type = EntitySignalType::SIGNAL_CREATE_BULLET_ENEMY;
			m_trigger.setEnabled(false);
		}

		// update destruction
		updateDestruction();
	}

	// Virtual method returns the type of the object - enumeration value
	const EntityType Enemy::getType() const
	{
		return EntityType::ENEMY;
	}

	// Virtual method returns the signal generated by the object
	const EntitySignalType Enemy::getSignal() const
	{
		return m_signal_type;
	}

}//namespace logic
